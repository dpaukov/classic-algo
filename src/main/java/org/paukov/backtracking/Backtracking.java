package org.paukov.backtracking;

import java.util.List;

/**
 * A skeleton class for all backtracking issues based on the recursive implementation.
 *
 * It searches all correct solution checked by the isCorrectSolution() method.
 * All possible solutions should be generated by the constructCandidates() method.
 */
public abstract class Backtracking<T, I> {

  /**
   * A special flag to stop the search if no more solutions are needed.
   */
  protected boolean finished = false;

  /**
   * Check if a provided constructed solution is correct or valid.
   * @param solution The provided full solution.
   * @param index The current index in the solution.
   * @param dataInput The initial data.
   */
  abstract boolean isCorrectSolution(T[] solution, int index, I dataInput);

  /**
   * Processes the correct solution. It can print the solution or add it another storage.
   * @param solution The provided full correct solution.
   * @param index The index of the last correct element in the solution.
   * @param dataInput The initial data.
   */
  abstract void processSolution(T[] solution, int index, I dataInput);

  /**
   * Construct a list of the possible candidates for the search based on the current provided
   * solution represented by the vector and the index.
   * @param vector The current state of the search.
   * @param index The last index of the search element.
   * @param dataInput The initial data.
   */
  abstract List<T> constructCandidates(T[] vector, int index, I dataInput);

  void makeMove(T[] vector, int k, I dataInput) {
  }

  void unmakeMove(T[] vector, int k, I dataInput) {
  }

  /**
   * Runs a search for the specified state represented by a vector and the index.
   * @param vector The current state of the search.
   * @param index The last index of the search element.
   * @param dataInput The initial data.
   */
  void run(T[] vector, int index, I dataInput) {
    if (isCorrectSolution(vector, index, dataInput)) {
      processSolution(vector, index, dataInput);
      return; // A solution is found.
    }
    for (T c : constructCandidates(vector, index, dataInput)) {
      vector[index + 1] = c;
      makeMove(vector, index + 1, dataInput);
      run(vector, index + 1, dataInput);
      unmakeMove(vector, index + 1, dataInput);
      if (finished) {
        return;
      }
    }
  }
}
